# **稀疏矩阵**
## **WACO**
### 摘要
- 利用稀疏卷积网络学习稀疏图案的特征，使用专门设计的调度模板在格式和调度中嵌入耦合行为
- 新的搜索策略：近似最近邻搜索 -> 有效地、准确地检索给定稀疏模式的最佳格式和调度

### 介绍
- 与在密集张量代数中不同，只要考虑张量的形状，稀疏张量代数的性能很大程度上依赖于张量复杂的稀疏模式
- TACO：稀疏张量代数编译器 -> 通过引入一个格式抽象，概括了许多提议的稀疏格式
- 稀疏迭代空间变换框架：允许编译器生成具有调度的代码，该调度执行循环分割、重新排序、并行化和其他任务 -> 以探索迭代空间的不同遍历顺序
- <u>已经建立了编译器的机制，使代码生成支持许多不同的格式和调度，编译器为给定的稀疏性模式决定最佳格式和最佳调度的策略尚未设计</u>
- 设计此策略与程序的自动调优问题密切相关，单一的格式和固定的实现不能对所有的稀疏模式做到全局优化
- 程序自动调优 -> 优化稠密张量程序 -> <u>性能取决于输入的大小</u> -> 通过对给定的输入形状进行经验性的程序转换
- Halide, Tiramisu,and TVM -> 将算法与调度基元解耦，以转变稠密张量程序中的循环结构 -> 允许表达更广泛的算法 and 因为调度而引入了一个巨大的搜索空间
- 目前的生产和最先进的研究系统有以下局限性
1. 捕获稀疏模式的局限性：
    现有的方法要么依赖人工制作的特征要么依赖降采样矩阵的卷积神经网络
2. 缺乏协同优化：
    考虑格式和调度之间的耦合行为
3. 本文方法：提出一个框架，对给定的稀疏模式，自动且联合优化格式和调度 -> 基于成本模型的深度学习 -> 新的稀疏卷积网络 -> 统一的调度模板-快速调度 -> 使用近似最近邻搜索 -> 快速搜索最佳的格式和调度

### 概述
<div align=center><img width = '400' height ='600' src ="https://s1.ax1x.com/2023/06/29/pCwHMM4.png"/></div>

- 设计成本模型预测程序运行时间，成本模型使用稀疏矩阵和超级调度，统一的模板同时定义格式和调度（a）
- 训练成本模型后，建立KNN图 -> 建立在均匀采样的超级调度的程序嵌入上（b）
- 对于一个给定的稀疏矩阵输入①，ANNS重复②、③两步，直至它收敛到一个局部最优的超级调度（c）

### 激励示例
<div align=center><img width = '400' height ='400' src ="https://s1.ax1x.com/2023/06/29/pCwOm79.png"/></div>

1. 协同优化的影响
- Table1通过比较三个不同调优空间上的自动调优结果：格式、调度 -> 显示了稀疏张量程序中协同优化的影响（其中基线使用有TACO生成的CSR调度）

2. 稀疏性模式依赖的性质
- 稀疏张量程序的性能对输入矩阵的稀疏性模式非常敏感，没有任何一种格式或实现可以显示所有稀疏模式的最佳性能，Table2可证实上述性质

### 回顾TACO
1. 描述TACO如何生成支持各种格式和迭代空间转换的代码
2. 描述了现有的稀疏张量程序自动调优的稀疏模式感知成本模型

- 张量代数编译器
1. TACO是一种稀疏张量代数领域特定语言，其附带的编译器将算法与数据表示和调度解耦
2. Chou介绍了一种格式抽象，它描述了稀疏张量如何以不同格式的坐标层次结构和级别格式进行存储 -> 提出了六种表示不同格式 -> 主要关注两种级别格式，未压缩格式和压缩格式
3. 格式抽象：下图显示了如何用格式抽象将CSR和BCSR格式表示出来
<div align=center><img width = '400' height ='350' src ="https://s1.ax1x.com/2023/06/29/pCwx7xx.png"/></div>

4. 通过调度的迭代空间变换:除了格式抽象之外，调度还决定了如何通过转换迭代空间来遍历以特定格式存储的张量.下图显示了C[i,j]=A[i,k]*B[k,j]的循环变换调度
<div align=center><img width = '400' height ='350' src ="https://s1.ax1x.com/2023/06/29/pCwxLqO.png"/></div>

- 自动调度的成本模型
1. 自动调度主要分两个部分。第一部分是快速预测程序性能的成本模型，第二部分是根据成本模型找到最佳调度的搜索策略 -> 实际的硬件测量可以作为一种成本来使用，但它非常耗时
2. 对于稀疏张量程序，理解稀疏模式是成本模型最关键的设计考虑因素
3. 两种提取稀疏张量特征的方法已经被广泛使用：(1)人工制作的特征和(2)一个在降采样张量上的卷积网络
4. 人工制作的特征：典型的特征是非零的总数，每行非零数的平均值或方差，以及特定于格式的特征，如从DIA格式到对角线的平均距离 -> 在确定准确性方面的有效性是未知的
5. 卷积神经网络：通过观察稀疏张量，将其当成图像来提取特征 -> 一个稀疏张量可以有许多不同的形状，但CNN只能接受一个固定大小的形状作为输入，所以稀疏张量被降采样到一个固定的形状 -> 导致局部模式信息的显著丢失
<div align=center><img width = '400' height ='200' src ="https://s1.ax1x.com/2023/06/30/pC0bxQU.png"/></div>

### 工作负载感知协同优化WACO
1. WACO是一个稀疏张量程序的自动调优框架，会自动从TACO生成的内容中搜索给定稀疏矩阵的最佳格式和调度

- 成本模型设计（三部分）
<div align=center><img width = '450' height ='200' src ="https://s1.ax1x.com/2023/06/30/pC0qMTA.png"/></div>

> 特征提取器：捕获输入矩阵的稀疏模式

- 探索不同的结构
1. 传统的CNN：:将稀疏矩阵视为密集矩阵，其中所有级别都以未压缩格式存储 -> 随着矩阵形状的增长，它很快就耗尽了计算资源
2. 递归神经网络：将稀疏张量视为一个坐标序列 -> 由于序列的长度（一些非零）是在数百万个尺度上的，递归神经网络不能记住所有的东西，也很容易忘记早期的序列
3. 使用CNN作为特征提取器：没有使用稠密卷积，而是对原始稀疏矩阵本身使用了稀疏卷积

- 稀疏卷积层
1. 对稀疏输入执行卷积操作，稀疏卷积只有在滤波器的中心为非零输入时才进行卷积操作 -> 减少计算量
<div align=center><img width = '400' height ='300' src ="https://s1.ax1x.com/2023/07/01/pCB7Hr4.png"/></div>

2. 当非零分布得很远时，会引起如下图所示的问题：只能捕获局部模式，而不能捕获全局模式 -> 因为非零的距离不够近，无法传播信息 -> 设计一个网络架构来解决稀疏矩阵有较远的非零分布的情况
<div align=center><img width = '400' height ='170' src ="https://s1.ax1x.com/2023/07/01/pCB7bqJ.png"/></div>

- WACONet：一种新的稀疏CNN架构
<div align=center><img width = '450' height ='300' src ="https://s1.ax1x.com/2023/07/01/pCBH3on.png"/></div>

1. 除了第一层，我们对每个稀疏卷积层使用3x3滤波器大小的串卷积 -> 多层叠加的分层卷积有助于远处的非零点，因为分层行为迫使接受场增加
<div align=center><img width = '390' height ='170' src ="https://s1.ax1x.com/2023/07/01/pCB7OaR.png"/></div>

2. 由于GPU的内存大小有限，稀疏卷积层中的通道数量较小（32） -> 若适用于具有大量非零点的稀疏矩阵，最高只可达1000万
3. WACONet在全局平均池化之后连接了所有14个中间结果，而不是使用最后一层的结果 -> 为了补偿由于通道数量有限而减少的网络容量
4. WACONet最大限度的减少了稀疏模式的信息损失，因为它将一个原始的稀疏矩阵作为输入，而没有任何降采样 + 由于卷积操作的性质，一个小的滤波器（3X3）可以识别局部模式，在通过多个分层的同时捕获全局模式 -> 通过简单地改变滤波器的维度，WACONet可以很容易地扩展到高维稀疏张量

> 程序嵌入器：理解格式和调度的耦合行为
- 挑战
1. 在稠密张量程序中，程序嵌入器只需要编码由低级循环抽象语法树反映的迭代空间的遍历顺序。然而，在稀疏张量程序中，程序嵌入器必须同时编码遍历顺序和格式，以准确理解联合优化的耦合行为
2. 如下图，嵌套循环中的级别数量由于调度的分割而变化 -> 搜索空间在分裂后也会扩展
<div align=center><img width = '400' height ='350' src ="https://s1.ax1x.com/2023/06/29/pCwxLqO.png"/></div>

3. 为了处理由于分裂造成的可变性，我们采用了模板指导的自动调度 + 模板同时指定了格式和调度，并直接在该模板上创建程序嵌入

- 超级调度
1. 下图显示了它是如何在矩阵向量乘法中定义超级调度模板 -> 由一个计算调度和一个格式调度组成 -> 计算调度定义了迭代空间的遍历顺序，格式调度定义了如何存储张量。格式调度中的重排决定了张量的层次顺序（例如，行主干或列主干），而计算调度中的重排决定了张量的遍历顺序
<div align=center><img width = '400' height ='220' src ="https://s1.ax1x.com/2023/07/02/pCDrL2q.png"/></div>

2. 一个已经有多个分割的调度模板可以减少到一个有更少分割的调度模板 -> 计算调度将每个索引(i和k)?最多分割一次，使MV算法($C[i]=A[i,k]*B[k]$)成为分割MV算法($C[i1,i0]=A[i1,i0,k1,k0]*B[k1,k0]$)
3. 在这个超级调度中，我们可以通过适当地选择分割大小为1来抽样所有的调度
```
(1) C[i1] = A[i1,k1] * B[k1]
(2) C[i1,i0] = A[i1,i0,k1] * B[k1]
(3) C[i1] = A[i1,k1,k0] * B[k1,k0]
(4) C[i1,i0] = A[i1,i0,k1,k0] * B[k1,k0]
```
4. 超级调度还可以推导出各种格式 -> e.g. 下图中的UC格式可以通过选择两个分割大小为1，并根据i1和k1的级别顺序将级别格式指定为UC而得出，UCUU同理
<div align=center><img width = '400' height ='350' src ="https://s1.ax1x.com/2023/06/29/pCwx7xx.png"/></div>

5. 超调度是一个完全分割算法下所有可能调度的超集 -> 下图中的MV和MM超级调度可以分别表示总共4个和8个分割算法，但超级调度可以代表更多的算法，这取决于定义多少个拆分 -> 我们选择了每个维度最多一个拆分，因为我们已经发现，超过一个拆分会产生递减的回报
<div align=center><img width = '400' height ='220' src ="https://s1.ax1x.com/2023/07/02/pCDrxqU.png"/></div>
<div align=center><img width = '800' height ='220' src ="https://s1.ax1x.com/2023/07/02/pCDsPi9.png"/></div>

- 网络结构
1. 基于模板的调度允许我们更容易地嵌入程序 -> 超级调度不是从底层循环抽象语法树中提取格式调度和计算调度，而是直接从模板的参数中提取每个循环的特性 -> 下面描述了评估中使用的每个调度及其可能的参数选择 -> 所有的参数都是分类的，除了重新排序，这需要一个指数的排列组合
<div align=center><img width = '400' height ='220' src ="https://s1.ax1x.com/2023/07/02/pCDyz4J.png"/></div>

2. 我们的程序嵌入器（下图）接收超级调度的参数并输出程序嵌入
<div align=center><img width = '800' height ='250' src ="https://s1.ax1x.com/2023/07/03/pCrVitI.png"/></div>

> 运行时预测器：将前几部分的结果串联起来，通过多个线性ReLU层预测运行时间



<div align=center><img width = '400' height ='450' src ="https://s1.ax1x.com/2023/07/03/pCrVu7j.png"/></div>

<div align=center><img width = '400' height ='650' src ="https://s1.ax1x.com/2023/07/03/pCrVwNR.png"/></div>

<div align=center><img width = '400' height ='220' src ="https://s1.ax1x.com/2023/07/03/pCrV2HH.png"/></div>

<div align=center><img width = '400' height ='200' src ="https://s1.ax1x.com/2023/07/03/pCrVfUA.png"/></div>

<div align=center><img width = '400' height ='200' src ="https://s1.ax1x.com/2023/07/03/pCrV5Ct.png"/></div>

<div align=center><img width = '600' height ='400' src ="https://s1.ax1x.com/2023/07/03/pCrVI8P.png"/></div>

<div align=center><img width = '400' height ='350' src ="https://s1.ax1x.com/2023/07/03/pCrVTv8.png"/></div>

<div align=center><img width = '400' height ='450' src ="https://s1.ax1x.com/2023/07/03/pCrVj5n.png"/></div>

<div align=center><img width = '400' height ='150' src ="https://s1.ax1x.com/2023/07/03/pCrZKKO.png"/></div>

<div align=center><img width = '400' height ='480' src ="https://s1.ax1x.com/2023/07/03/pCrZMrD.png"/></div>

<div align=center><img width = '400' height ='480' src ="https://s1.ax1x.com/2023/07/03/pCrZQqe.png"/></div>